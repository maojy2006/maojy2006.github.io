<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>MySQL百万数据ST_Distance_Sphere函数的优化实践 - Maudoo&#x27;s blog</title><meta name="description" content="78万+条订单数据，使用ST_Distance_Sphere函数判断两点距离进行比较"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://maojy2006.cn/mysql_st_distance_sphere/"><link rel="alternate" type="application/atom+xml" href="https://maojy2006.cn/feed.xml"><link rel="alternate" type="application/json" href="https://maojy2006.cn/feed.json"><meta property="og:title" content="MySQL百万数据ST_Distance_Sphere函数的优化实践"><meta property="og:site_name" content="Maudoo's blog"><meta property="og:description" content="78万+条订单数据，使用ST_Distance_Sphere函数判断两点距离进行比较"><meta property="og:url" content="https://maojy2006.cn//mysql_st_distance_sphere/"><meta property="og:type" content="article"><link rel="stylesheet" href="https://maojy2006.cn/assets/css/fontawesome-all.min.css?v=85514f933f9e0b82460af63f1a403fa5"><link rel="stylesheet" href="https://maojy2006.cn/assets/css/style.css?v=9274fb62a8095432057114afc1a7f7fc"><noscript><link rel="stylesheet" href="https://maojy2006.cn/assets/css/noscript.css?v=efa867a99f5064d6729e4dc2008ad50b"></noscript><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://maojy2006.cn/mysql_st_distance_sphere/"},"headline":"MySQL百万数据ST_Distance_Sphere函数的优化实践","datePublished":"2025-08-06T21:30","dateModified":"2025-08-08T15:46","description":"78万+条订单数据，使用ST_Distance_Sphere函数判断两点距离进行比较","author":{"@type":"Person","name":"maudoo","url":"https://maojy2006.cn/authors/maudoo/"},"publisher":{"@type":"Organization","name":"maudoo"}}</script><style>#wrapper > .bg {
               background-image: url(https://maojy2006.cn/assets/images/overlay.png), linear-gradient(0deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(https://maojy2006.cn/media/website/home-2.jpg);
           }</style><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="is-preload post-template"><div id="wrapper"><header id="header"><a class="logo" href="https://maojy2006.cn/">Maudoo&#x27;s blog</a></header><nav id="nav"><ul class="links"></ul></nav><main id="main"><article class="post"><header class="major"><time datetime="2025-08-06T21:30" class="date">八月 6, 2025</time><h1>MySQL百万数据ST_Distance_Sphere函数的优化实践</h1><p class="post__inner">78万+条订单数据，使用ST_Distance_Sphere函数判断两点距离进行比较</p></header><div class="post__inner post__entry"><h2 id="场景">场景</h2><p>78万+条订单数据，使用ST_Distance_Sphere函数逐个判断两点距离进行比较</p><figure class="post__image"><img src="https://media.doge.maojy2006.cn/blog/2025/2025-08-05-09-18-35-image.png" alt="待优化代码" data-is-external-image="true"></figure><p>待优化代码</p><figure class="post__image"><img loading="lazy" src="https://media.doge.maojy2006.cn/blog/2025/2025-08-05-09-14-28-image.png" alt="" data-is-external-image="true"></figure><p>每次接口收到请求，查询数据库需要完成一次全表扫描，逐个比对且对每一条数据都执行一次昂贵的球面距离计算。</p><table><thead><tr><th>type</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>ALL</td><td>1685899</td><td>Using where</td></tr></tbody></table><p>优化前查询耗时约30秒，正在召唤测试跟前端的连环拷打ing~</p><h2 id="表结构优化-添加point索引">表结构优化-添加Point索引</h2><p>当前存储经纬度的结构，且只创建了一个B+数索引</p><pre><code class="language-java">    pre_destination_longitude    decimal(10, 6) null comment &#39;预计目的地经度&#39;,
    pre_destination_latitude     decimal(10, 6) null comment &#39;预计目的地纬度&#39;,
...
create index idx_order_info_dest
    on order_information (pre_destination_longitude, pre_destination_latitude);
</code></pre><p>于是添加空间索引</p><blockquote><p>空间索引的作用，就是给数据库一张“地图”，让它能从“大海捞针”的全表扫描，变成“按图索骥”的精准打击。</p></blockquote><p>由于表中不止网约车订单数据（筛选条件<code>order_type IS NULL</code>），因此可能有部分数据存在pre_destination_longitude、pre_destination_latitude数据为null的情况。但是创建空间索引必须要限制列为非空格式，就像地图上不应该存在不知道位置的点。故采用下面语句修改表结构，将为null的数据设置为“无害的默认值 ”</p><p>下面这段SQL耗时较长（共180万+条数据跑了10分钟多），运行时注意环境</p><pre><code class="language-java">-- 第1步：添加一个允许为NULL的列
ALTER TABLE order_information 
ADD COLUMN `coordinate` POINT NULL COMMENT &#39;经纬度坐标点-索引加速&#39;;

-- 第2步：用现有数据填充这个新列
UPDATE order_information 
SET coordinate = POINT(pre_destination_longitude, pre_destination_latitude) 
WHERE pre_destination_longitude IS NOT NULL AND pre_destination_latitude IS NOT NULL;

-- 第3步：处理那些经纬度本身就是NULL的数据
UPDATE order_information 
SET coordinate = POINT(0, 0) 
WHERE coordinate IS NULL;

-- 第4步：修改列定义为 NOT NULL
ALTER TABLE order_information 
MODIFY COLUMN `coordinate` POINT NOT NULL COMMENT &#39;经纬度坐标点-索引加速&#39;;

-- 第5步：创建空间索引
CREATE SPATIAL INDEX `idx_spatial_coordinate` ON `order_information`(`coordinate`);
</code></pre><p>空间索引创建完还需要优化SQL。</p><p>优化逻辑：</p><ol><li>在java层以入参坐标（及半径）为中心，在地图中划出待查询范围，略去绝大部分区域</li><li>在正方形中比较坐标距离，最后获得圆形区域中包含的各点</li></ol><figure class="post__image"><img loading="lazy" src="https://media.doge.maojy2006.cn/blog/2025/yuque_mind.jpeg" alt="画板" data-is-external-image="true"></figure><p>不止这一种SQL层优化方案，现在使用的是 边界框+空间索引的方案</p><p>还有包括但不限于：Partitioning (分区)、<font style="color:rgb(44, 44, 54);">Z-Order(混合经纬度)</font></p><p>如果你需要了解更多 请看–&gt;<a href="https://mysql.rjweb.org/doc.php/find_nearest_in_mysql">MySQL Techniques for “Find Nearest”</a></p><p>但是主播在与AI的搏斗中始终没能让它给出合适的、能在我的MySQL用上创建的Point类索引的SQL。如果看到这的你知道了可以教教我</p><p>≧ ﹏ ≦</p><p>而且数据库设计文档即将完工，不好意思让写文档的同学再修改，于是尝试其他方法</p><h2 id="程序逻辑优化-整合redis实现缓存">程序逻辑优化-整合Redis实现缓存</h2><p>我以业务逻辑为主线实现的Redis缓存。业务要求打开页面获得选择框 /getNameTable，选定某一区域获得其详细信息并且详细信息分为三页。其中第二页 /showPage2 内容需要连接多表且数据量极大的表，返回数据时间基本上在十几秒，而其他页面的访问速度并不需要通过缓存优化。但是 /showPage2 的传参多样，因此并不是很合适在启动的时候全部预加载存入Redis。因此我选择通过调用第一页 /showPage1 时使用多线程技术实现后台预加载第二页数据，在缓存加载成功后切换页面的速度将有极大提升。</p><p>实现线程池</p><pre><code class="language-java">package com.name.project.config;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

/**
 * @Description 自定义创建线程池
 */
@Configuration
public class ThreadPoolConfig {
    @Bean(&quot;preCacheExecutor&quot;)
    public ExecutorService preCacheExecutor() {
        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
                .setNameFormat(&quot;precache-pool-%d&quot;).build();

        // 创建一个固定大小的线程池-根据业务需求量执行线程池大小
        return Executors.newFixedThreadPool(8, namedThreadFactory);
    }
}
</code></pre><p>实现类中整合Redis的加载方式</p><pre><code class="language-java">//新增整合了Redis的方法调用模式
@Override
public DataResult&lt;MapShowPage2&gt; getMapShowPage2WithCache(String longitude, String latitude, String name) {
    // 1. 生成缓存键
    String cacheKey = &quot;mapShowPage2:&quot; + longitude + &quot;:&quot; + latitude + &quot;:&quot; + name;

    // 2. 尝试从缓存获取
    MapShowPage2 cachedResult = (MapShowPage2) redisTemplate.opsForValue().get(cacheKey);
    if (cachedResult != null) {
        return DataResult.success(cachedResult);
    }

    // 3. 缓存未命中，执行业务逻辑获取数据，showPage2为业务代码
    DataResult&lt;MapShowPage2&gt; result = this.showPage2(longitude, latitude, name);

    // 4. 存入缓存并设置过期时间(24小时)
    if (result != null &amp;&amp; result.getData() != null) {
        redisTemplate.opsForValue().set(cacheKey, result.getData(), 24, TimeUnit.HOURS);
    }

    // 5. 返回结果
    return result;
}

//修改showPage1方法
@Override
public DataResult&lt;MapShowPage1&gt; showPage1(String longitude,String latitude,String name) {

    //实现第二页预加载
    // 使用CompletableFuture.runAsync提交一个异步任务
    CompletableFuture.runAsync(() -&gt; {
        // 这部分代码将在preCacheExecutor线程池中的某个线程上运行
        try {
            System.out.println(&quot;线程 [&quot; + Thread.currentThread().getName() + &quot;] 开始异步预热第二页缓存...&quot;);
            this.getMapShowPage2WithCache(longitude, latitude, name);
            System.out.println(&quot;线程 [&quot; + Thread.currentThread().getName() + &quot;] 异步预热任务结束。&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }, preCacheExecutor);

...原本业务逻辑...

}
</code></pre><p>Redis缓存后可以实现毫秒级响应</p><p>对各请求查询请求次数再搭配定时任务可以实现对热门需求的定时刷新。</p><h2 id="程序逻辑优化-springboot定时任务">程序逻辑优化-SpringBoot定时任务</h2><p>@Scheduled(fixedRate = 10 * 24 * 60 * 60 * 1000)</p></div><footer class="post__inner post__footer"><p class="post__last-updated">This article was updated on 八月 8, 2025</p><div class="post__share-tag-container"><div class="post__share"><button class="post__share-button js-post__share-button icon" aria-label="Share button"><i class="fas fa-share-alt"></i></button><div class="post__share-popup js-post__share-popup"></div></div></div><div class="post__bio"><div><h3><a href="https://maojy2006.cn/authors/maudoo/" class="invert" rel="author">maudoo</a></h3></div></div></footer></article></main><footer id="copyright"><ul><li>© Maudoo</li><li><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener">粤ICP备2025444811号</a></li><li>Design: <a href="https://html5up.net" target="_blank" rel="nofollow noopener">HTML5 UP</a></li><li>Powered by Publii+github+cloudflare</li></ul></footer></div><script src="https://maojy2006.cn/assets/js/jquery.min.js?v=c9771cc3e90e18f5336eedbd0fffb2cf"></script><script src="https://maojy2006.cn/assets/js/jquery.scrollex.min.js?v=f89065e3d988006af9791b44561d7c90"></script><script src="https://maojy2006.cn/assets/js/jquery.scrolly.min.js?v=1ed5a78bde1476875a40f6b9ff44fc14"></script><script src="https://maojy2006.cn/assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="https://maojy2006.cn/assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="https://maojy2006.cn/assets/js/util.min.js?v=4201a626f8c9b614a663b3a1d7d82615"></script><script src="https://maojy2006.cn/assets/js/main.min.js?v=56233c354bd814758be8bff42f7e13a5"></script><script>/*<![CDATA[*/var images=document.querySelectorAll("img[loading]");for(var i=0;i<images.length;i++){if(images[i].complete){images[i].classList.add("is-loaded")}else{images[i].addEventListener("load",function(){this.classList.add("is-loaded")},false)}};/*]]>*/</script></body></html>